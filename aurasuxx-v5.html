<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <title>WiFi Router Adventure - Endless Mode</title>
    
    <!--
    ============================================================
    WIFI ROUTER ADVENTURE - ENDLESS MODE
    ============================================================
    
    Mobile-friendly infinite platformer!
    - Touch controls for mobile
    - Camera only moves forward (Mario style)
    - Progressive difficulty
    - Global scoreboard
    ============================================================
    -->
    
    <!-- Supabase Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        
        #game-container {
            position: relative;
            width: 1600px; /* 2.22:1 aspect ratio for mobile */
            height: 720px;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(0, 200, 255, 0.3);
            flex-shrink: 0;
            transform-origin: center center; /* Critical for scaling */
        }
        
        #game-canvas {
            display: block;
            background: #87CEEB;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.3) 100%);
            border-radius: 20px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
            pointer-events: none;
        }
        
        .hud-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .hud-icon {
            font-size: 18px;
        }
        
        .hud-label {
            font-size: 10px;
            opacity: 0.7;
        }
        
        /* Music Player Controls */
        #music-player {
            display: none;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
        }
        
        #music-player.visible {
            display: flex;
        }
        
        .music-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .music-btn:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.1);
        }
        
        .music-btn:active {
            transform: scale(0.95);
        }
        
        #volume-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            cursor: pointer;
        }
        
        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        #volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        #track-name {
            font-size: 10px;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            opacity: 0.8;
        }
        
        #difficulty-bar {
            position: absolute;
            top: 50px;
            left: 10px;
            right: 10px;
            height: 4px;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            z-index: 10;
            overflow: hidden;
        }
        
        #difficulty-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00FF00, #FFFF00, #FF6600, #FF0000);
            border-radius: 2px;
            transition: width 0.5s ease;
        }
        
        #difficulty-text {
            position: absolute;
            top: 58px;
            left: 10px;
            color: rgba(255,255,255,0.6);
            font-size: 10px;
            z-index: 10;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        #zone-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        #zone-indicator.show {
            opacity: 1;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(26,26,46,0.98) 0%, rgba(22,33,62,0.98) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #start-screen h1 {
            color: #fff;
            font-size: 42px;
            text-shadow: 
                0 0 20px rgba(0,200,255,0.8),
                0 0 40px rgba(255,100,200,0.5);
            margin-bottom: 10px;
            animation: pulse 2s infinite;
            text-align: center;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #start-screen .subtitle {
            color: #00D4FF;
            font-size: 18px;
            margin-bottom: 8px;
        }
        
        #start-screen .description {
            color: #aaa;
            font-size: 13px;
            margin-bottom: 25px;
            text-align: center;
            max-width: 90%;
            line-height: 1.4;
        }
        
        .global-badge {
            background: linear-gradient(135deg, #00D4FF 0%, #0099CC 100%);
            color: white;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .endless-badge {
            background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
            color: white;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 8px;
        }
        
        #start-btn {
            padding: 14px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 30px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 30px rgba(240,147,251,0.4);
        }
        
        #start-btn:hover, #start-btn:active {
            transform: translateY(-2px);
            box-shadow: 0 8px 35px rgba(240,147,251,0.6);
        }
        
        #controls-info {
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            margin-top: 20px;
            text-align: center;
            line-height: 1.6;
        }
        
        .penalty-notice {
            color: #FF6B6B;
            font-size: 11px;
            margin-top: 12px;
            text-align: center;
        }
        
        #game-over-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
        }
        
        #game-over-screen h2 {
            color: #f5576c;
            font-size: 36px;
            margin-bottom: 12px;
            text-shadow: 0 0 30px rgba(245,87,108,0.8);
        }
        
        .stats-container {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stat-box {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 10px 18px;
            text-align: center;
        }
        
        .stat-box .label {
            color: #aaa;
            font-size: 10px;
            text-transform: uppercase;
        }
        
        .stat-box .value {
            color: #fff;
            font-size: 22px;
            font-weight: bold;
        }
        
        #name-input-section {
            margin: 10px 0;
            text-align: center;
            display: none;  /* Hidden by default, shown when needed */
        }
        
        #player-name-input {
            padding: 10px 15px;
            font-size: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            outline: none;
            margin: 8px;
            min-width: 180px;
        }
        
        #player-name-input::placeholder {
            color: rgba(255,255,255,0.5);
        }
        
        #player-name-input:focus {
            border-color: #667eea;
        }
        
        /* Gamepad Name Entry */
        #gamepad-name-entry {
            display: none;
            flex-direction: column;
            align-items: center;
            margin: 15px 0;
        }
        
        #current-name-display {
            font-size: 24px;
            color: #fff;
            background: rgba(0,0,0,0.4);
            padding: 10px 30px;
            border-radius: 8px;
            margin-bottom: 15px;
            min-width: 200px;
            text-align: center;
            border: 2px solid #667eea;
        }
        
        #letter-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 400px;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .letter-btn {
            width: 36px;
            height: 36px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .letter-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .letter-btn.selected {
            background: #667eea;
            border-color: #fff;
            box-shadow: 0 0 15px rgba(102,126,234,0.8);
            transform: scale(1.1);
        }
        
        .letter-btn.action {
            width: 80px;
            background: rgba(255,100,100,0.3);
        }
        
        .letter-btn.action.selected {
            background: #f5576c;
        }
        
        .letter-btn.submit-btn {
            background: rgba(100,200,100,0.3);
            width: 120px;
        }
        
        .letter-btn.submit-btn.selected {
            background: #2ECC71;
        }
        
        #gamepad-name-hint {
            color: #aaa;
            font-size: 11px;
            margin-top: 5px;
        }
        
        #submit-score-btn {
            padding: 10px 25px;
            font-size: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #submit-score-btn:hover, #submit-score-btn:active {
            transform: translateY(-2px);
        }
        
        #submit-score-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #scoreboard-section {
            margin: 10px 0;
        }
        
        #scoreboard-table {
            border-collapse: collapse;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
            width: 90%;
            max-width: 400px;
            margin: 0 auto;
        }
        
        #scoreboard-table th,
        #scoreboard-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        #scoreboard-table th {
            background: rgba(102,126,234,0.3);
            color: #fff;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 10px;
        }
        
        #scoreboard-table td {
            color: #fff;
            font-size: 13px;
        }
        
        .rank-1 { color: #FFD700 !important; }
        .rank-2 { color: #C0C0C0 !important; }
        .rank-3 { color: #CD7F32 !important; }
        
        .loading-indicator {
            color: #aaa;
            font-size: 12px;
            margin-top: 8px;
        }
        
        #restart-btn {
            padding: 12px 35px;
            font-size: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }
        
        #restart-btn:hover, #restart-btn:active {
            transform: scale(1.05);
        }
        
        #penalty-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.8);
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        #penalty-popup.show {
            opacity: 1;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            z-index: 20;
            pointer-events: none;
        }
        
        .mobile-btn {
            position: absolute;
            width: 75px;  /* Standard size for L/R */
            height: 75px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 3px solid rgba(255,255,255,0.4);
            color: white;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            touch-action: manipulation;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        .mobile-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }
        
        #btn-left {
            left: 30px;
            bottom: 30px;
        }
        
        #btn-right {
            left: 125px; /* Spaced away from Left button */
            bottom: 30px;
        }
        
        /* The Enormo-Jump Button */
        #btn-jump {
            right: 40px;  /* Anchored to the far RIGHT */
            bottom: 30px;
            width: 125px; /* ~35% larger than movement buttons */
            height: 125px;
            background: rgba(0, 150, 255, 0.4); /* Blue tint */
            border: 4px solid rgba(255, 255, 255, 0.7);
            font-size: 32px;
        }

        /* Show mobile controls on touch devices */
        @media (pointer: coarse) {
            #mobile-controls {
                display: block;
            }
        }
            #hud {
                top: 5px;
                padding: 6px 12px;
                font-size: 14px;
            }
            #difficulty-bar {
                top: 40px;
            }
            #difficulty-text {
                top: 48px;
            }
        }
        
        /* Responsive */
        @media (max-width: 600px) {
            #start-screen h1 {
                font-size: 28px;
            }
            #start-screen .subtitle {
                font-size: 14px;
            }
            #start-screen .description {
                font-size: 11px;
            }
            #start-btn {
                padding: 12px 30px;
                font-size: 16px;
            }
            #controls-info {
                font-size: 10px;
            }
            .mobile-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
            #btn-left {
                left: 15px;
                bottom: 15px;
            }
            #btn-right {
                left: 85px;
                bottom: 15px;
            }
            #btn-jump {
                right: 20px;
                bottom: 15px;
                width: 75px;
                height: 75px;
                font-size: 28px;
            }

        }
    
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
}

</style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="1600" height="720"></canvas>
        
        <div id="hud">
            <div class="hud-item">
                <span class="hud-icon">üì∂</span>
                <span id="coin-count">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-icon">‚≠ê</span>
                <span id="score-count">0</span>
            </div>
            
            <!-- Music Player -->
            <div id="music-player">
                <button class="music-btn" id="music-prev" title="Previous">‚èÆ</button>
                <button class="music-btn" id="music-play" title="Play/Pause">‚ñ∂</button>
                <button class="music-btn" id="music-next" title="Next">‚è≠</button>
                <input type="range" id="volume-slider" min="0" max="100" value="30" title="Volume">
                <span id="track-name">-</span>
            </div>
            
            <div class="hud-item">
                <span class="hud-icon">üìè</span>
                <span id="distance-count">0</span><span class="hud-label">m</span>
            </div>
            <div class="hud-item">
                <span class="hud-icon">‚ù§Ô∏è</span>
                <span id="lives-count">3</span>
            </div>
            <div class="hud-item" id="gamepad-indicator" style="display: none;">
                <span class="hud-icon">üéÆ</span>
            </div>
        </div>

        <div id="difficulty-bar">
            <div id="difficulty-fill"></div>
        </div>
        <div id="difficulty-text">Difficulty: Easy</div>
        <div id="zone-indicator"></div>
        
        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-left">‚óÄ</button>
            <button class="mobile-btn" id="btn-right">‚ñ∂</button>
            <button class="mobile-btn" id="btn-jump">‚¨Ü</button>
        </div>
        
        <div id="start-screen">
            <h1>üì∂ WiFi Router Adventure</h1>
            <div class="subtitle">ENDLESS MODE <span class="endless-badge">‚àû</span></div>
            <div class="description">
                Run endlessly through procedurally generated worlds!<br>
                Difficulty increases as you progress.
            </div>
            <button id="start-btn">START GAME</button>
            <div id="controls-info">
                <strong>Desktop:</strong> ‚Üê ‚Üí or A/D to move | SPACE/W to jump<br>
                <strong>Mobile:</strong> Use on-screen buttons<br>
                <strong>Gamepad:</strong> Left stick/D-pad to move | A/B to jump
            </div>
            <div class="penalty-notice">‚ö†Ô∏è Death penalty: Lose 10% of your score!</div>
            <div class="penalty-notice">‚ö†Ô∏è PS: VIHANE IS NOT ALLOWED TO STEAL THIS CODE FOR HIS OWN PROJECTS!</div>
        </div>
        
        <div id="game-over-screen">
            <h2>GAME OVER</h2>
            <div class="stats-container">
                <div class="stat-box">
                    <div class="label">Final Score</div>
                    <div class="value" id="final-score">0</div>
                </div>
                <div class="stat-box">
                    <div class="label">Distance</div>
                    <div class="value" id="final-distance">0m</div>
                </div>
                <div class="stat-box">
                    <div class="label">Coins</div>
                    <div class="value" id="final-coins">0</div>
                </div>
            </div>
            
            <div id="name-input-section">
                <p style="color: #aaa; margin-bottom: 8px; font-size: 13px;">Enter your name for the global scoreboard:</p>
                <input type="text" id="player-name-input" maxlength="15" placeholder="Your name">
                <button id="submit-score-btn">Submit Score</button>
                <div id="submit-status" class="loading-indicator"></div>
            </div>
            
            <!-- Gamepad Name Entry -->
            <div id="gamepad-name-entry">
                <div id="current-name-display">_</div>
                <div id="letter-grid"></div>
                <div id="gamepad-name-hint">‚Üê ‚Üí Move | A Select | B Delete | Start Submit</div>
                <div id="submit-status-gamepad" class="loading-indicator"></div>
            </div>
            
            <div id="scoreboard-section" style="display: none;">
                <h3 style="color: #fff; margin: 15px 0 10px; font-size: 18px;">üèÜ Global Leaderboard <span class="global-badge">LIVE</span></h3>
                <table id="scoreboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Name</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody id="scoreboard-body"></tbody>
                </table>
                <div id="scoreboard-loading" class="loading-indicator">Loading...</div>
            </div>
            
            <button id="restart-btn">Play Again</button>
        </div>
        
        <div id="penalty-popup">-10% Score!</div>
    </div>

    <script>
    'use strict';

    // ========================================
    // SUPABASE CONFIGURATION
    // ========================================
    const SUPABASE_URL = 'https://puvyrteqszjemepsdpcq.supabase.co';
    const SUPABASE_ANON_KEY = 'sb_publishable_3rCLoASI73FtPatcaEZDmg_F2D6ez_6';
    
    let supabaseClient = null;
    try {
        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('Supabase initialized');
    } catch (e) {
        console.error('Supabase failed:', e);
    }

    // ========================================
    // MUSIC PLAYLIST - Add your audio files here!
    // ========================================
    // Just add your MP3/OGG files to the same folder as this HTML file,
    // then list them in this array. Example:
    // const MUSIC_PLAYLIST = ['track1.mp3', 'track2.mp3', 'background_music.ogg'];
    const MUSIC_PLAYLIST = ['1-muidu-TP-Link Will Never Die.mp3', '2-muidu-TP-Link Rulez.mp3', '3-muidu-Cuba Libre Reigns.mp3'];  // Empty = no music controls shown

    // ========================================
    // ENEMY TYPES CONFIGURATION
    // ========================================
    // Add or modify enemy types here. Each type has:
    // - name: Display name shown under enemy
    // - bodyColor: Main router body color
    // - borderColor: Router border/stroke color
    // - stripeColor: Top stripe color
    // - spawnWeight: Higher = spawns more often (all weights sum to ~100)
    const ENEMY_TYPES = [
        { name: 'AURA', bodyColor: '#8B4513', borderColor: '#6B3510', stripeColor: '#7a3d20', ledColors: ['#886600', '#FF0000', '#333333', '#FF6600'], eyeColor: '#8B0000', spawnWeight: 20 },
        { name: 'LINKSYS', bodyColor: '#2C3E50', borderColor: '#1A252F', stripeColor: '#34495E', ledColors: ['#00FF00', '#00FF00', '#FFAA00', '#0088FF'], eyeColor: '#E74C3C', spawnWeight: 18 },
        { name: 'CISCO', bodyColor: '#1E3A5F', borderColor: '#0D2137', stripeColor: '#2E5077', ledColors: ['#00D4FF', '#00D4FF', '#00FF88', '#00D4FF'], eyeColor: '#00BFFF', spawnWeight: 16 },
        { name: 'ZTE', bodyColor: '#4A4A6A', borderColor: '#2D2D4A', stripeColor: '#5A5A7A', ledColors: ['#00FF88', '#00FF88', '#FFAA00', '#FF6644'], eyeColor: '#00FF88', spawnWeight: 14 },
        { name: 'NETGEAR', bodyColor: '#3D5A3D', borderColor: '#2A402A', stripeColor: '#4A6B4A', ledColors: ['#00FF00', '#FF6600', '#00FF00', '#FF6600'], eyeColor: '#00AA00', spawnWeight: 12 },
        { name: 'ASUS', bodyColor: '#5A2D0A', borderColor: '#3D1E07', stripeColor: '#7A3D10', ledColors: ['#FF0000', '#FF0000', '#FFAA00', '#00FF00'], eyeColor: '#FF4444', spawnWeight: 10 },
        { name: 'HUAWEI', bodyColor: '#8B0000', borderColor: '#5C0000', stripeColor: '#AA2020', ledColors: ['#FFFFFF', '#FF0000', '#00FF00', '#FFAA00'], eyeColor: '#FF0000', spawnWeight: 8 },
        { name: 'TP-LINK', bodyColor: '#2ECC71', borderColor: '#27AE60', stripeColor: '#3EDD81', ledColors: ['#00FF00', '#00FF00', '#00FF00', '#FFAA00'], eyeColor: '#27AE60', spawnWeight: 0 },  // Rare "good" twin
    ];

    // ========================================
    // MUSIC PLAYER
    // ========================================
    let musicPlayer = null;
    
    class MusicPlayer {
        constructor(playlist) {
            this.playlist = playlist;
            this.currentIndex = 0;
            this.isPlaying = false;
            this.audio = null;
            
            if (playlist.length > 0) {
                this.init();
            }
        }
        
        init() {
            // Create audio element
            this.audio = new Audio();
            this.audio.volume = 0.3;
            
            // Auto-advance to next track when current ends
            this.audio.addEventListener('ended', () => this.next());
            
            // Show player UI
            document.getElementById('music-player').classList.add('visible');
            
            // Setup button events
            document.getElementById('music-play').addEventListener('click', () => this.togglePlay());
            document.getElementById('music-next').addEventListener('click', () => this.next());
            document.getElementById('music-prev').addEventListener('click', () => this.prev());
            document.getElementById('volume-slider').addEventListener('input', (e) => {
                this.audio.volume = e.target.value / 100;
            });
            
            // Load first track
            this.loadTrack(0);
        }
        
        loadTrack(index) {
            if (this.playlist.length === 0) return;
            
            this.currentIndex = index;
            this.audio.src = this.playlist[index];
            
            // Update track name display
            const trackName = this.playlist[index].replace(/\.[^/.]+$/, ''); // Remove extension
            document.getElementById('track-name').textContent = trackName;
            
            // Auto-play if was playing
            if (this.isPlaying) {
                this.audio.play().catch(() => {});
            }
        }
        
        togglePlay() {
            if (this.isPlaying) {
                this.audio.pause();
                this.isPlaying = false;
                document.getElementById('music-play').textContent = '‚ñ∂';
            } else {
                this.audio.play().then(() => {
                    this.isPlaying = true;
                    document.getElementById('music-play').textContent = '‚è∏';
                }).catch(e => console.log('Audio play failed:', e));
            }
        }
        
        next() {
            let nextIndex = this.currentIndex + 1;
            if (nextIndex >= this.playlist.length) {
                nextIndex = 0; // Loop back to first
            }
            this.loadTrack(nextIndex);
        }
        
        prev() {
            let prevIndex = this.currentIndex - 1;
            if (prevIndex < 0) {
                prevIndex = this.playlist.length - 1; // Go to last
            }
            this.loadTrack(prevIndex);
        }
        
        start() {
            // Called when game starts - try to play
            if (this.audio && !this.isPlaying) {
                this.audio.play().then(() => {
                    this.isPlaying = true;
                    document.getElementById('music-play').textContent = '‚è∏';
                }).catch(() => {}); // Ignore autoplay restrictions
            }
        }
    }
    
    // Initialize music player
    musicPlayer = new MusicPlayer(MUSIC_PLAYLIST);

    // ========================================
    // UTILITY FUNCTIONS
    // ========================================
    function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.arcTo(x + width, y, x + width, y + radius, radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
        ctx.lineTo(x + radius, y + height);
        ctx.arcTo(x, y + height, x, y + height - radius, radius);
        ctx.lineTo(x, y + radius);
        ctx.arcTo(x, y, x + radius, y, radius);
        ctx.closePath();
    }
    
    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
    function randomRange(min, max) { return Math.random() * (max - min) + min; }
    function seededRandom(seed) { const x = Math.sin(seed) * 10000; return x - Math.floor(x); }

    // ========================================
    // CANVAS SETUP
    // ========================================
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const CANVAS_WIDTH = canvas.width;
    const CANVAS_HEIGHT = canvas.height;
    const GROUND_Y = CANVAS_HEIGHT - 40;

    // ========================================
    // GAME CONSTANTS
    // ========================================
    const GRAVITY = 0.5;
    const FRICTION = 0.88;
    const AIR_RESISTANCE = 0.96;
    const PLAYER_SPEED = 3.5;
    const JUMP_FORCE = -13;
    const TILE_SIZE = 40;
    
    const GENERATION_DISTANCE = 2000;
    const CLEANUP_DISTANCE = 500;
    const CHUNK_WIDTH = 400;
    const DEATH_PENALTY = 0.10;
    
    const DIFFICULTY_SETTINGS = {
        enemySpeed: [0.8, 2.5],
        gapSize: [80, 180],
        platformHeight: [165, 175],      // Min 165px = 3 char heights (fits under)
        enemyFrequency: [0.3, 0.7],
        coinFrequency: [0.6, 0.4],
        movingPlatformChance: [0.15, 0.15]  // 15% moving, 85% static
    };

    // ========================================
    // GAME STATE
    // ========================================
    let gameState = 'start';
    let score = 0;
    let coins_collected = 0;
    let distance = 0;
    let lives = 3;
    let cameraX = 0;
    let maxCameraX = 0;  // Track furthest camera position (no going back!)
    let difficulty = 0;
    let currentZone = 0;
    let lastGeneratedX = 0;
    let seed = 0;

    // ========================================
    // INPUT HANDLING
    // ========================================
    const keys = { left: false, right: false, up: false, down: false, jump: false };

    // ========================================
    // GAMEPAD SUPPORT
    // ========================================
    let gamepadConnected = false;
    let gamepadIndex = null;
    let lastStartPress = false;  // For debouncing menu buttons
    let lastBackPress = false;
    let lastAPress = false;      // For name entry
    let lastBPress = false;

    // Gamepad name entry state
    let gamepadNameMode = false;
    let enteredName = '';
    let letterGridCursor = 0;
    let lastLetterNavTime = 0;
    const LETTER_NAV_DELAY = 150;  // ms between navigation moves
    const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'.split('');

    window.addEventListener('gamepadconnected', (e) => {
        console.log('üéÆ Gamepad connected:', e.gamepad.id);
        gamepadConnected = true;
        gamepadIndex = e.gamepad.index;
        document.getElementById('gamepad-indicator').style.display = 'flex';
    });

    window.addEventListener('gamepaddisconnected', (e) => {
        console.log('üéÆ Gamepad disconnected');
        gamepadConnected = false;
        gamepadIndex = null;
        document.getElementById('gamepad-indicator').style.display = 'none';
    });

    // Generate the letter grid for gamepad name entry
    function generateLetterGrid() {
        const grid = document.getElementById('letter-grid');
        grid.innerHTML = '';
        
        // Add letters A-Z, 0-9, and underscore
        LETTERS.forEach((letter, index) => {
            const btn = document.createElement('button');
            btn.className = 'letter-btn';
            btn.textContent = letter;
            btn.dataset.index = index;
            btn.addEventListener('click', () => selectLetter(letter));
            grid.appendChild(btn);
        });
        
        // Add DEL button
        const delBtn = document.createElement('button');
        delBtn.className = 'letter-btn action';
        delBtn.textContent = 'DEL';
        delBtn.dataset.index = LETTERS.length;
        delBtn.addEventListener('click', deleteLastLetter);
        grid.appendChild(delBtn);
        
        // Add SUBMIT button
        const submitBtn = document.createElement('button');
        submitBtn.className = 'letter-btn submit-btn';
        submitBtn.textContent = 'SUBMIT';
        submitBtn.dataset.index = LETTERS.length + 1;
        submitBtn.addEventListener('click', submitGamepadName);
        grid.appendChild(submitBtn);
        
        updateLetterGridSelection();
    }

    function updateLetterGridSelection() {
        const buttons = document.querySelectorAll('#letter-grid .letter-btn');
        buttons.forEach((btn, index) => {
            btn.classList.toggle('selected', index === letterGridCursor);
        });
    }

    function updateNameDisplay() {
        const display = document.getElementById('current-name-display');
        display.textContent = enteredName + (enteredName.length < 15 ? '_' : '');
    }

    function selectLetter(letter) {
        if (enteredName.length < 15) {
            enteredName += letter === '_' ? ' ' : letter;
            updateNameDisplay();
        }
    }

    function deleteLastLetter() {
        enteredName = enteredName.slice(0, -1);
        updateNameDisplay();
    }

    async function submitGamepadName() {
        if (enteredName.trim().length === 0) {
            enteredName = 'Player';
        }
        
        const status = document.getElementById('submit-status-gamepad');
        status.textContent = 'Submitting...';
        
        const success = await submitScore(enteredName.trim(), score, distance, coins_collected);
        status.textContent = success ? 'Submitted!' : 'Failed';
        status.style.color = success ? '#00FF00' : '#FF6600';
        
        if (success) {
            document.getElementById('gamepad-name-entry').style.display = 'none';
            await displayScoreboard();
        }
    }

    function showGamepadNameEntry() {
        gamepadNameMode = true;
        enteredName = '';
        letterGridCursor = 0;
        document.getElementById('name-input-section').style.display = 'none';
        document.getElementById('gamepad-name-entry').style.display = 'flex';
        document.getElementById('submit-status-gamepad').textContent = '';
        generateLetterGrid();
        updateNameDisplay();
    }

    function hideGamepadNameEntry() {
        gamepadNameMode = false;
        document.getElementById('gamepad-name-entry').style.display = 'none';
    }

    function pollGamepad() {
        if (!gamepadConnected || gamepadIndex === null) return;

        const gamepads = navigator.getGamepads();
        const gp = gamepads[gamepadIndex];
        if (!gp) return;

        // Left stick X-axis (axis 0) or D-pad (buttons 14/15 on standard gamepad)
        const stickX = gp.axes[0];
        const dpadLeft = gp.buttons[14] ? gp.buttons[14].pressed : false;
        const dpadRight = gp.buttons[15] ? gp.buttons[15].pressed : false;

        // Movement: stick or d-pad
        keys.left = stickX < -0.3 || dpadLeft;
        keys.right = stickX > 0.3 || dpadRight;

        // Jump: A button (button 0) or B button (button 1)
        keys.jump = gp.buttons[0].pressed || gp.buttons[1].pressed;

        // Menu navigation with gamepad
        // Start button (button 9) - Start game / Restart / Submit name
        const startPressed = gp.buttons[9].pressed;
        if (startPressed && !lastStartPress) {
            if (gameState === 'start') {
                startGame();
            } else if (gameState === 'gameover' && gamepadNameMode) {
                // Submit name from gamepad entry
                submitGamepadName();
            } else if (gameState === 'gameover') {
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('name-input-section').style.display = 'block';
                document.getElementById('scoreboard-section').style.display = 'none';
                document.getElementById('player-name-input').value = '';
                document.getElementById('submit-status').textContent = '';
                startGame();
            }
        }
        lastStartPress = startPressed;

        // Back/Select (button 8) or Y (button 3) - Return to title screen
        const backPressed = gp.buttons[8].pressed || gp.buttons[3].pressed;
        if (backPressed && !lastBackPress) {
            if (gameState === 'playing' || gameState === 'gameover') {
                // Reset everything and go to title screen
                gameState = 'start';
                hideGamepadNameEntry();
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('start-screen').style.display = 'flex';
                score = 0;
                coins_collected = 0;
                distance = 0;
                lives = 3;
            }
        }
        lastBackPress = backPressed;

        // Letter grid navigation for name entry
        if (gamepadNameMode) {
            const now = Date.now();
            const totalButtons = LETTERS.length + 2;  // letters + DEL + SUBMIT
            
            // Navigate with d-pad or left stick (with delay to prevent too fast movement)
            const stickX = gp.axes[0];
            const stickY = gp.axes[1];
            const dpadLeft = gp.buttons[14] ? gp.buttons[14].pressed : false;
            const dpadRight = gp.buttons[15] ? gp.buttons[15].pressed : false;
            const dpadUp = gp.buttons[12] ? gp.buttons[12].pressed : false;
            const dpadDown = gp.buttons[13] ? gp.buttons[13].pressed : false;
            
            const cols = 10;  // 10 letters per row
            const goLeft = stickX < -0.5 || dpadLeft;
            const goRight = stickX > 0.5 || dpadRight;
            const goUp = stickY < -0.5 || dpadUp;
            const goDown = stickY > 0.5 || dpadDown;
            
            if (now - lastLetterNavTime > LETTER_NAV_DELAY) {
                if (goLeft) {
                    letterGridCursor = (letterGridCursor - 1 + totalButtons) % totalButtons;
                    lastLetterNavTime = now;
                    updateLetterGridSelection();
                }
                if (goRight) {
                    letterGridCursor = (letterGridCursor + 1) % totalButtons;
                    lastLetterNavTime = now;
                    updateLetterGridSelection();
                }
                if (goUp) {
                    letterGridCursor = Math.max(0, letterGridCursor - cols);
                    lastLetterNavTime = now;
                    updateLetterGridSelection();
                }
                if (goDown) {
                    letterGridCursor = Math.min(totalButtons - 1, letterGridCursor + cols);
                    lastLetterNavTime = now;
                    updateLetterGridSelection();
                }
            }
            
            // A button - select letter/action
            const aPressed = gp.buttons[0].pressed;
            if (aPressed && !lastAPress) {
                if (letterGridCursor < LETTERS.length) {
                    selectLetter(LETTERS[letterGridCursor]);
                } else if (letterGridCursor === LETTERS.length) {
                    deleteLastLetter();
                } else if (letterGridCursor === LETTERS.length + 1) {
                    submitGamepadName();
                }
            }
            lastAPress = aPressed;
            
            // B button (button 1) - delete
            const bPressed = gp.buttons[1].pressed;
            if (bPressed && !lastBPress) {
                deleteLastLetter();
            }
            lastBPress = bPressed;
        }
    }

    // ========================================
    // GAME OBJECTS
    // ========================================
    let assetManager = null;
    let audioManager = null;
    let background = null;
    let player = null;
    let platforms = [];
    let coinsArray = [];
    let enemies = [];
    let particles = [];
    let weather = null;

    // ========================================
    // ASSET MANAGER
    // ========================================
    class AssetManager {
        constructor() {
            this.assets = {};
            this.createDefaultAssets();
        }

        createDefaultAssets() {
            this.assets.player = this.createPlayerSprite();
            this.assets.platform = this.createPlatformSprite();
            // Create sprites for all enemy types
            for (let i = 0; i < ENEMY_TYPES.length; i++) {
                this.assets['enemy_' + i] = this.createEnemySprite(i);
            }
            this.assets.coin = this.createCoinSprite(false);
            this.assets.goldCoin = this.createCoinSprite(true);
        }

        createPlayerSprite() {
            const c = document.createElement('canvas');
            c.width = 50; c.height = 65;
            const s = c.getContext('2d');
            
            // Antennas
            s.fillStyle = '#1a1a1a';
            s.fillRect(8, 0, 4, 25);
            s.fillStyle = '#2d2d2d';
            s.beginPath(); s.arc(10, 0, 4, 0, Math.PI * 2); s.fill();
            
            s.fillStyle = '#1a1a1a';
            s.fillRect(23, -5, 4, 30);
            s.fillStyle = '#2d2d2d';
            s.beginPath(); s.arc(25, -5, 4, 0, Math.PI * 2); s.fill();
            
            s.fillStyle = '#1a1a1a';
            s.fillRect(38, 0, 4, 25);
            s.fillStyle = '#2d2d2d';
            s.beginPath(); s.arc(40, 0, 4, 0, Math.PI * 2); s.fill();
            
            // Body
            s.fillStyle = '#2ECC71';
            drawRoundedRect(s, 2, 22, 46, 38, 6);
            s.fill();
            s.strokeStyle = '#27AE60';
            s.lineWidth = 2;
            drawRoundedRect(s, 2, 22, 46, 38, 6);
            s.stroke();
            
            // LEDs
            s.fillStyle = '#00FF00';
            s.shadowColor = '#00FF00'; s.shadowBlur = 5;
            s.beginPath(); s.arc(10, 50, 2, 0, Math.PI * 2); s.fill();
            s.beginPath(); s.arc(18, 50, 2, 0, Math.PI * 2); s.fill();
            s.beginPath(); s.arc(26, 50, 2, 0, Math.PI * 2); s.fill();
            s.fillStyle = '#FFAA00';
            s.beginPath(); s.arc(34, 50, 2, 0, Math.PI * 2); s.fill();
            s.beginPath(); s.arc(40, 50, 2, 0, Math.PI * 2); s.fill();
            s.shadowBlur = 0;
            
            // Face
            s.fillStyle = '#ffffff';
            s.beginPath(); s.ellipse(17, 45, 5, 6, 0, 0, Math.PI * 2); s.ellipse(33, 45, 5, 6, 0, 0, Math.PI * 2); s.fill();
            s.fillStyle = '#2C3E50';
            s.beginPath(); s.arc(18, 45, 3, 0, Math.PI * 2); s.arc(34, 45, 3, 0, Math.PI * 2); s.fill();
            s.fillStyle = '#ffffff';
            s.beginPath(); s.arc(19, 44, 1.5, 0, Math.PI * 2); s.arc(35, 44, 1.5, 0, Math.PI * 2); s.fill();
            s.strokeStyle = '#1a1a1a'; s.lineWidth = 2;
            s.beginPath(); s.arc(25, 48, 6, 0.2, Math.PI - 0.2); s.stroke();
            
            return c;
        }

        createPlatformSprite() {
            const c = document.createElement('canvas');
            c.width = TILE_SIZE; c.height = TILE_SIZE;
            const s = c.getContext('2d');
            
            s.fillStyle = '#8B4513';
            s.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            s.fillStyle = '#A0522D';
            s.fillRect(2, 2, 16, 16);
            s.fillRect(22, 2, 16, 16);
            s.fillRect(12, 22, 16, 16);
            s.fillRect(2, 22, 8, 16);
            s.fillRect(30, 22, 8, 16);
            s.fillStyle = '#228B22';
            s.fillRect(0, 0, TILE_SIZE, 6);
            s.fillStyle = 'rgba(255,255,255,0.2)';
            s.fillRect(0, 0, TILE_SIZE, 2);
            
            return c;
        }

        createEnemySprite(typeIndex) {
            const c = document.createElement('canvas');
            c.width = 50; c.height = 55;
            const s = c.getContext('2d');
            
            const type = ENEMY_TYPES[typeIndex];
            
            // Antenna
            s.fillStyle = '#4a4a4a';
            s.fillRect(21, 0, 8, 18);
            s.fillStyle = '#3a3a3a';
            s.fillRect(23, -8, 4, 18);
            s.fillStyle = '#5a5a5a';
            s.beginPath(); s.arc(25, -8, 4, 0, Math.PI * 2); s.fill();
            
            // Body - using enemy type colors
            s.fillStyle = type.bodyColor;
            drawRoundedRect(s, 2, 15, 46, 38, 3);
            s.fill();
            s.strokeStyle = type.borderColor;
            s.lineWidth = 2;
            drawRoundedRect(s, 2, 15, 46, 38, 3);
            s.stroke();
            
            // Top stripe
            s.fillStyle = type.stripeColor;
            s.fillRect(4, 17, 42, 8);
            
            // Ventilation lines
            s.fillStyle = '#4a4a4a';
            for (let i = 0; i < 4; i++) s.fillRect(6, 30 + i * 4, 38, 2);
            
            // LEDs - using enemy type LED colors
            const leds = type.ledColors;
            s.shadowBlur = 2;
            for (let i = 0; i < 4; i++) {
                const ledX = 10 + i * 10;
                s.fillStyle = leds[i];
                s.shadowColor = leds[i];
                s.beginPath();
                s.arc(ledX, 46, 2.5, 0, Math.PI * 2);
                s.fill();
            }
            s.shadowBlur = 0;
            
            // Eyes
            s.fillStyle = '#ffffff';
            s.beginPath(); s.ellipse(16, 38, 6, 4, 0, 0, Math.PI * 2); s.ellipse(34, 38, 6, 4, 0, 0, Math.PI * 2); s.fill();
            s.fillStyle = type.eyeColor;
            s.beginPath(); s.arc(17, 38, 2, 0, Math.PI * 2); s.arc(35, 38, 2, 0, Math.PI * 2); s.fill();
            
            // Angry eyebrows
            s.strokeStyle = '#2a2a2a'; s.lineWidth = 2;
            s.beginPath(); s.moveTo(10, 32); s.lineTo(22, 35); s.stroke();
            s.beginPath(); s.moveTo(40, 32); s.lineTo(28, 35); s.stroke();
            
            // Evil smile
            s.beginPath(); s.arc(25, 46, 5, Math.PI + 0.3, -0.3); s.stroke();
            
            return c;
        }

        createCoinSprite(isGold) {
            const c = document.createElement('canvas');
            c.width = 30; c.height = 30;
            const s = c.getContext('2d');
            
            // Gold or blue colors
            const color1 = isGold ? '#FFD700' : '#00D4FF';
            const color2 = isGold ? '#FFA500' : '#0099CC';
            const color3 = isGold ? '#FF8C00' : '#006699';
            const glowColor = isGold ? '#FFD700' : '#00D4FF';
            const strokeColor = isGold ? '#FFFF00' : '#00FFFF';
            
            const g = s.createRadialGradient(15, 15, 3, 15, 15, 14);
            g.addColorStop(0, color1);
            g.addColorStop(0.5, color2);
            g.addColorStop(1, color3);
            
            s.fillStyle = g;
            s.beginPath(); s.arc(15, 15, 14, 0, Math.PI * 2); s.fill();
            
            s.shadowColor = glowColor; s.shadowBlur = 5;
            s.strokeStyle = strokeColor; s.lineWidth = 2;
            s.beginPath(); s.arc(15, 15, 12, 0, Math.PI * 2); s.stroke();
            s.shadowBlur = 0;
            
            // WiFi signal bars
            s.strokeStyle = '#ffffff'; s.lineWidth = 2; s.lineCap = 'round';
            s.beginPath(); s.arc(15, 20, 4, Math.PI, 0, false); s.stroke();
            s.beginPath(); s.arc(15, 20, 7, Math.PI, 0, false); s.stroke();
            s.beginPath(); s.arc(15, 20, 10, Math.PI, 0, false); s.stroke();
            s.fillStyle = '#ffffff';
            s.beginPath(); s.arc(15, 20, 2, 0, Math.PI * 2); s.fill();
            
            return c;
        }

        get(name) { return this.assets[name]; }
    }

    // ========================================
    // AUDIO MANAGER
    // ========================================
    class AudioManager {
        constructor() {
            this.audioContext = null;
            this.sfxGain = null;
            this.sfxVolume = 0.7;
            this.initialized = false;
        }

        init() {
            if (this.initialized) return;
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.sfxGain = this.audioContext.createGain();
                this.sfxGain.connect(this.audioContext.destination);
                this.sfxGain.gain.value = this.sfxVolume;
                this.initialized = true;
            } catch (e) {
                console.warn('Audio not supported');
            }
        }

        playSfx(type) {
            if (!this.initialized) return;
            try {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                osc.connect(gain);
                gain.connect(this.sfxGain);
                const now = this.audioContext.currentTime;
                
                if (type === 'jump') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                    gain.gain.setValueAtTime(0.3 * this.sfxVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'coin') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, now);
                    osc.frequency.setValueAtTime(1108, now + 0.05);
                    osc.frequency.setValueAtTime(1318, now + 0.1);
                    gain.gain.setValueAtTime(0.2 * this.sfxVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                } else if (type === 'hurt') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                    gain.gain.setValueAtTime(0.3 * this.sfxVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                } else if (type === 'stomp') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.4 * this.sfxVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'death') {
                    // Dramatic death sound
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.8);
                    gain.gain.setValueAtTime(0.4 * this.sfxVolume, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    
                    // Second oscillator for more impact
                    const osc2 = this.audioContext.createOscillator();
                    const gain2 = this.audioContext.createGain();
                    osc2.connect(gain2);
                    gain2.connect(this.sfxGain);
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(200, now + 0.1);
                    osc2.frequency.exponentialRampToValueAtTime(30, now + 0.6);
                    gain2.gain.setValueAtTime(0.2 * this.sfxVolume, now + 0.1);
                    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    osc2.start(now + 0.1); osc2.stop(now + 0.6);
                } else if (type === 'thunder') {
                    // Thunder - deep rumble with crack
                    const noise = this.audioContext.createBufferSource();
                    const bufferSize = this.audioContext.sampleRate * 1.5;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
                    }
                    noise.buffer = buffer;
                    
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 200;
                    
                    const thunderGain = this.audioContext.createGain();
                    thunderGain.gain.setValueAtTime(0.5 * this.sfxVolume, now);
                    thunderGain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                    
                    noise.connect(filter);
                    filter.connect(thunderGain);
                    thunderGain.connect(this.sfxGain);
                    noise.start(now);
                }
            } catch (e) {}
        }
        
        // Continuous rain sound
        startRainSound() {
            if (!this.initialized || this.rainSource) return;
            
            try {
                // Create noise buffer for rain
                const bufferSize = this.audioContext.sampleRate * 2;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                this.rainSource = this.audioContext.createBufferSource();
                this.rainSource.buffer = buffer;
                this.rainSource.loop = true;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 3000;
                
                this.rainGain = this.audioContext.createGain();
                this.rainGain.gain.value = 0;
                
                this.rainSource.connect(filter);
                filter.connect(this.rainGain);
                this.rainGain.connect(this.sfxGain);
                this.rainSource.start();
            } catch (e) {}
        }
        
        setRainVolume(vol) {
            if (this.rainGain) {
                this.rainGain.gain.value = vol * this.sfxVolume;
            }
        }
        
        stopRainSound() {
            if (this.rainSource) {
                this.rainSource.stop();
                this.rainSource = null;
                this.rainGain = null;
            }
        }
    }

    // ========================================
    // PARTICLE
    // ========================================
    class Particle {
        constructor(x, y, opts) {
            opts = opts || {};
            this.x = x; this.y = y;
            this.vx = opts.vx !== undefined ? opts.vx : (Math.random() - 0.5) * 4;
            this.vy = opts.vy !== undefined ? opts.vy : (Math.random() - 0.5) * 4 - 2;
            this.size = opts.size !== undefined ? opts.size : Math.random() * 6 + 2;
            this.color = opts.color || '#FFD700';
            this.life = opts.life !== undefined ? opts.life : 1;
            this.decay = opts.decay !== undefined ? opts.decay : 0.02;
            this.gravity = opts.gravity !== undefined ? opts.gravity : 0.1;
        }

        update() {
            this.x += this.vx; this.y += this.vy;
            this.vy += this.gravity;
            this.life -= this.decay;
            this.size *= 0.98;
        }

        draw(ctx, camX) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x - camX, this.y, Math.max(0.5, this.size), 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowColor = this.color; ctx.shadowBlur = 10;
            ctx.fill();
            ctx.restore();
        }

        isDead() { return this.life <= 0 || this.size < 0.5; }
    }

    // ========================================
    // PLAYER
    // ========================================
    class Player {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 46; this.height = 55;
            this.vx = 0; this.vy = 0;
            this.grounded = false;
            this.facing = 1;
            this.invincible = false;
            this.invincibleTimer = 0;
            this.animFrame = 0;
            this.animTimer = 0;
            this.state = 'idle';
            this.currentPlatform = null;
            this.lastPlatformX = 0;
            this.lastPlatformY = 0;
        }

        update() {
            // Move with platform
            if (this.currentPlatform && this.grounded) {
                const dx = this.currentPlatform.x - this.lastPlatformX;
                const dy = this.currentPlatform.y - this.lastPlatformY;
                this.x += dx; this.y += dy;
                this.lastPlatformX = this.currentPlatform.x;
                this.lastPlatformY = this.currentPlatform.y;
            }
            
            // Input
            if (keys.left) { this.vx -= PLAYER_SPEED * 0.15; this.facing = -1; }
            if (keys.right) { this.vx += PLAYER_SPEED * 0.15; this.facing = 1; }
            
            // Friction
            if (this.grounded) this.vx *= FRICTION;
            else this.vx *= AIR_RESISTANCE;
            
            // Clamp
            this.vx = clamp(this.vx, -PLAYER_SPEED, PLAYER_SPEED);
            
            // Gravity
            this.vy += GRAVITY;
            this.vy = Math.min(this.vy, 15);
            
            // Jump
            if (keys.jump && this.grounded) {
                this.vy = JUMP_FORCE;
                this.grounded = false;
                this.currentPlatform = null;
                if (audioManager) audioManager.playSfx('jump');
                
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(this.x + this.width / 2, this.y + this.height,
                        { vx: (Math.random() - 0.5) * 3, vy: Math.random() * -2, color: '#A0522D', size: Math.random() * 4 + 2, gravity: 0.05 }));
                }
            }
            
            // Horizontal collision
            this.x += this.vx;
            for (const p of platforms) {
                if (this.collidesWith(p)) {
                    if (this.vx > 0) this.x = p.x - this.width;
                    else if (this.vx < 0) this.x = p.x + p.width;
                    this.vx = 0;
                }
            }
            
            // Vertical collision
            this.y += this.vy;
            this.grounded = false;
            this.currentPlatform = null;
            
            for (const p of platforms) {
                if (this.collidesWith(p)) {
                    if (this.vy > 0) {
                        this.y = p.y - this.height;
                        this.grounded = true;
                        this.vy = 0;
                        this.currentPlatform = p;
                        this.lastPlatformX = p.x;
                        this.lastPlatformY = p.y;
                    } else if (this.vy < 0) {
                        this.y = p.y + p.height;
                        this.vy = 0;
                    }
                }
            }
            
            // Coins
            for (let i = coinsArray.length - 1; i >= 0; i--) {
                const c = coinsArray[i];
                if (this.collidesWith(c)) {
                    coinsArray.splice(i, 1);
                    score += c.value;
                    coins_collected++;
                    if (audioManager) audioManager.playSfx('coin');
                    const particleColor = c.isGold ? '#FFD700' : '#00D4FF';
                    for (let j = 0; j < 8; j++) {
                        particles.push(new Particle(c.x + c.width / 2, c.y + c.height / 2, { color: particleColor, gravity: 0.05, decay: 0.03 }));
                    }
                }
            }
            
            // Enemies
            if (!this.invincible) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    if (this.collidesWith(e)) {
                        if (this.vy > 0 && this.y + this.height - e.y < 20) {
                            enemies.splice(i, 1);
                            score += 150;  // 150 points for killing enemy
                            this.vy = JUMP_FORCE * 0.7;
                            if (audioManager) audioManager.playSfx('stomp');
                            for (let j = 0; j < 12; j++) {
                                particles.push(new Particle(e.x + e.width / 2, e.y + e.height / 2, { color: '#8B4513', gravity: 0.1, decay: 0.02 }));
                            }
                        } else {
                            this.takeDamage();
                        }
                    }
                }
            }
            
            // Animation
            if (!this.grounded) this.state = this.vy < 0 ? 'jumping' : 'falling';
            else if (Math.abs(this.vx) > 0.5) this.state = 'running';
            else this.state = 'idle';
            
            this.animTimer++;
            if (this.animTimer > 8) { this.animTimer = 0; this.animFrame = (this.animFrame + 1) % 4; }
            
            if (this.invincible) { this.invincibleTimer--; if (this.invincibleTimer <= 0) this.invincible = false; }
        }

        takeDamage() {
            lives--;
            this.invincible = true;
            this.invincibleTimer = 120;
            this.vy = JUMP_FORCE * 0.5;
            this.vx = -this.facing * 5;
            
            // Death penalty
            if (score > 0) {
                const penalty = Math.floor(score * DEATH_PENALTY);
                score = Math.max(0, score - penalty);
                showPenaltyPopup();
            }
            
            if (audioManager) audioManager.playSfx('hurt');
            
            if (lives <= 0) {
                // Game over - play death sound
                if (audioManager) audioManager.playSfx('death');
                
                gameState = 'gameover';
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('final-score').textContent = score.toLocaleString();
                document.getElementById('final-distance').textContent = Math.floor(distance) + 'm';
                document.getElementById('final-coins').textContent = coins_collected;
                
                // Show gamepad name entry if gamepad is connected, otherwise show keyboard input
                if (gamepadConnected) {
                    showGamepadNameEntry();
                } else {
                    document.getElementById('name-input-section').style.display = 'block';
                }
            }
        }

        collidesWith(o) {
            return this.x < o.x + o.width && this.x + this.width > o.x && this.y < o.y + o.height && this.y + this.height > o.y;
        }

        draw(ctx, camX) {
            ctx.save();
            const dx = this.x - camX;
            const dy = this.y;
            
            if (this.invincible && Math.floor(this.invincibleTimer / 5) % 2 === 0) ctx.globalAlpha = 0.5;
            
            const sprite = assetManager.get('player');
            
            if (this.facing === -1) { ctx.translate(dx + this.width, dy); ctx.scale(-1, 1); }
            else ctx.translate(dx, dy);
            
            if (sprite) {
                let bob = this.state === 'running' ? Math.sin(this.animFrame * Math.PI / 2) * 2 : 0;
                ctx.drawImage(sprite, -2, -10 + bob);
            }
            
            ctx.restore();
            
            // Text
            ctx.save();
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('TP-LINK', dx + this.width / 2, dy + 28);
            ctx.restore();
        }
    }

    // ========================================
    // PLATFORM
    // ========================================
    class Platform {
        constructor(x, y, w, h, type) {
            this.x = x; this.y = y;
            this.width = w; this.height = h || 40;
            this.type = type || 'ground';
            this.originalX = x; this.originalY = y;
            this.moveRange = 0; this.moveSpeed = 0; this.moveAxis = 'x';
            this.moveOffset = Math.random() * Math.PI * 2;
        }

        setMoving(range, speed, axis) {
            this.moveRange = range; this.moveSpeed = speed; this.moveAxis = axis || 'x';
            this.type = 'moving';
            return this;
        }

        update() {
            if (this.type === 'moving') {
                this.moveOffset += this.moveSpeed;
                if (this.moveAxis === 'x') this.x = this.originalX + Math.sin(this.moveOffset) * this.moveRange;
                else this.y = this.originalY + Math.sin(this.moveOffset) * this.moveRange;
            }
        }

        draw(ctx, camX) {
            const dx = this.x - camX;
            const sprite = assetManager.get('platform');
            
            if (this.height >= 40) {
                const tiles = Math.ceil(this.width / TILE_SIZE);
                for (let i = 0; i < tiles; i++) {
                    const tx = dx + i * TILE_SIZE;
                    const tw = Math.min(TILE_SIZE, this.width - i * TILE_SIZE);
                    if (sprite) ctx.drawImage(sprite, tx, this.y, tw, this.height);
                    else { ctx.fillStyle = '#8B4513'; ctx.fillRect(tx, this.y, tw, this.height); ctx.fillStyle = '#228B22'; ctx.fillRect(tx, this.y, tw, 6); }
                }
            } else {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(dx, this.y, this.width, this.height);
                ctx.fillStyle = '#228B22';
                ctx.fillRect(dx, this.y, this.width, 6);
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(dx, this.y, this.width, 2);
            }
        }
    }

    // ========================================
    // COIN
    // ========================================
    class Coin {
        constructor(x, y, isGold = false) {
            this.x = x; this.y = y;
            this.width = 24; this.height = 24;
            this.originalY = y;
            this.animTimer = Math.random() * Math.PI * 2;
            this.isGold = isGold;
            this.value = isGold ? 300 : 100;
        }

        update() { this.animTimer += 0.08; this.y = this.originalY + Math.sin(this.animTimer) * 5; }

        draw(ctx, camX) {
            const dx = this.x - camX;
            const sprite = assetManager.get(this.isGold ? 'goldCoin' : 'coin');
            const spin = Math.cos(this.animTimer * 2);
            const dw = this.width * Math.abs(spin);
            if (sprite) ctx.drawImage(sprite, dx + (this.width - dw) / 2, this.y, dw, this.height);
        }
    }

    // ========================================
    // ENEMY - Now with multiple types!
    // ========================================
    class Enemy {
        constructor(x, y, range, speed, typeIndex) {
            this.x = x; this.y = y;
            this.width = 46; this.height = 50;
            this.originalX = x;
            this.patrolRange = range || 100;
            this.speed = speed || 1.0;
            this.direction = 1;
            this.animFrame = 0; this.animTimer = 0;
            this.typeIndex = typeIndex;
            this.name = ENEMY_TYPES[typeIndex].name;
        }

        update() {
            this.x += this.speed * this.direction;
            if (this.x > this.originalX + this.patrolRange) this.direction = -1;
            else if (this.x < this.originalX) this.direction = 1;
            this.animTimer++;
            if (this.animTimer > 10) { this.animTimer = 0; this.animFrame = (this.animFrame + 1) % 2; }
        }

        draw(ctx, camX) {
            const dx = this.x - camX;
            const sprite = assetManager.get('enemy_' + this.typeIndex);
            
            ctx.save();
            if (this.direction === -1) { ctx.translate(dx + this.width, this.y); ctx.scale(-1, 1); }
            else ctx.translate(dx, this.y);
            
            if (sprite) ctx.drawImage(sprite, -2, -8 - this.animFrame * 2);
            ctx.restore();
            
            // Draw enemy name
            ctx.save();
            ctx.fillStyle = '#D4A574';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.name, dx + this.width / 2, this.y + 15);
            ctx.restore();
        }
    }

    // ========================================
    // BACKGROUND
    // ========================================
    class Background {
        constructor() {
            this.layers = [
                { speed: 0.1, color1: '#1a1a3e', color2: '#2d2d5a', elements: this.genMountains(5, 0.3) },
                { speed: 0.3, color1: '#2a2a5a', color2: '#3d3d7a', elements: this.genMountains(7, 0.5) },
                { speed: 0.5, color1: '#3a5a3a', color2: '#4a7a4a', elements: this.genHills(10) }
            ];
        }

        genMountains(count, hf) {
            const m = []; const sp = CANVAS_WIDTH / count;
            for (let i = 0; i < count; i++) m.push({ x: i * sp + Math.random() * sp * 0.5, width: sp * (1 + Math.random() * 0.5), height: CANVAS_HEIGHT * hf * (0.7 + Math.random() * 0.3) });
            return m;
        }

        genHills(count) {
            const h = []; const sp = CANVAS_WIDTH / count;
            for (let i = 0; i < count; i++) h.push({ x: i * sp, width: sp * 2, height: 50 + Math.random() * 80 });
            return h;
        }

        draw(ctx, camX, weather) {
            const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            
            // Get sky darkness from weather
            const skyDarkness = weather ? weather.getSkyDarkness() : 0;
            
            if (currentZone === 0) { 
                grad.addColorStop(0, this.darkenColor('#87CEEB', skyDarkness)); 
                grad.addColorStop(0.5, this.darkenColor('#B0E0E6', skyDarkness)); 
                grad.addColorStop(1, this.darkenColor('#E0F6FF', skyDarkness)); 
            }
            else if (currentZone === 1) { 
                grad.addColorStop(0, this.darkenColor('#FFB347', skyDarkness)); 
                grad.addColorStop(0.5, this.darkenColor('#FFCC80', skyDarkness)); 
                grad.addColorStop(1, this.darkenColor('#FFE4B5', skyDarkness)); 
            }
            else if (currentZone === 2) { 
                grad.addColorStop(0, this.darkenColor('#4A0080', skyDarkness)); 
                grad.addColorStop(0.5, this.darkenColor('#6B238E', skyDarkness)); 
                grad.addColorStop(1, this.darkenColor('#8B4513', skyDarkness)); 
            }
            else { 
                grad.addColorStop(0, this.darkenColor('#1a1a2e', skyDarkness)); 
                grad.addColorStop(0.5, this.darkenColor('#16213e', skyDarkness)); 
                grad.addColorStop(1, this.darkenColor('#0f3460', skyDarkness)); 
            }
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            for (let i = 0; i < this.layers.length; i++) {
                const l = this.layers[i];
                const ox = camX * l.speed;
                
                if (i < 2) {
                    for (const m of l.elements) {
                        const dx = ((m.x - ox) % (CANVAS_WIDTH + m.width)) - m.width / 2;
                        ctx.fillStyle = i === 0 ? l.color1 : l.color2;
                        ctx.beginPath(); ctx.moveTo(dx, CANVAS_HEIGHT); ctx.lineTo(dx + m.width / 2, CANVAS_HEIGHT - m.height); ctx.lineTo(dx + m.width, CANVAS_HEIGHT); ctx.closePath(); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(dx + CANVAS_WIDTH, CANVAS_HEIGHT); ctx.lineTo(dx + CANVAS_WIDTH + m.width / 2, CANVAS_HEIGHT - m.height); ctx.lineTo(dx + CANVAS_WIDTH + m.width, CANVAS_HEIGHT); ctx.closePath(); ctx.fill();
                    }
                } else {
                    for (const h of l.elements) {
                        const dx = ((h.x - ox) % (CANVAS_WIDTH + h.width)) - h.width / 2;
                        ctx.fillStyle = l.color1;
                        ctx.beginPath(); ctx.ellipse(dx + h.width / 2, CANVAS_HEIGHT, h.width / 2, h.height, 0, Math.PI, 0); ctx.fill();
                    }
                }
            }
            
            // Clouds
            const cp = [100, 400, 700, 1000, 1300, 1600, 1900];
            
            // Get cloud color from weather
            let cloudColor = currentZone >= 2 ? 'rgba(100,100,150,0.5)' : 'rgba(255,255,255,0.8)';
            if (weather) {
                const weatherCloud = weather.getCloudColor();
                if (weatherCloud) cloudColor = weatherCloud;
            }
            
            ctx.fillStyle = cloudColor;
            for (let i = 0; i < cp.length; i++) {
                const bx = (cp[i] - camX * 0.05) % (CANVAS_WIDTH + 200) - 100;
                const by = 50 + (i % 4) * 50;
                ctx.beginPath(); ctx.arc(bx, by, 30, 0, Math.PI * 2); ctx.arc(bx + 40, by - 15, 40, 0, Math.PI * 2); ctx.arc(bx + 85, by, 35, 0, Math.PI * 2); ctx.arc(bx + 45, by + 15, 28, 0, Math.PI * 2); ctx.fill();
            }
        }
        
        // Helper to darken colors for stormy weather
        darkenColor(hex, factor) {
            if (factor <= 0) return hex;
            
            // Parse hex color
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);
            
            // Darken
            r = Math.floor(r * (1 - factor * 0.6));
            g = Math.floor(g * (1 - factor * 0.6));
            b = Math.floor(b * (1 - factor * 0.6));
            
            return `rgb(${r}, ${g}, ${b})`;
        }
    }

    // ========================================
    // WEATHER SYSTEM
    // ========================================
    class Weather {
        constructor() {
            this.types = ['clear', 'rain', 'storm', 'fog'];
            this.current = 'clear';
            this.timer = 0;
            this.changeInterval = 30 * 60;
            
            this.rainDrops = [];
            this.maxRainDrops = 200;
            
            this.lightningFlash = 0;
            this.lightningTimer = 0;
            this.nextLightning = Math.random() * 300 + 200;
            
            this.fogLayers = [];
            this.fogOpacity = 0;
            this.targetFogOpacity = 0;
            this.fogHeight = 'bottom';
            
            this.transitionTimer = 0;
            this.skyDarkness = 0;
        }
        
        update() {
            this.timer++;
            
            if (this.timer >= this.changeInterval) {
                this.timer = 0;
                this.changeWeather();
            }
            
            if (this.current === 'rain' || this.current === 'storm') {
                this.updateRain();
                this.skyDarkness = Math.min(1, this.skyDarkness + 0.02);
                
                if (this.current === 'storm') {
                    this.updateLightning();
                }
            } else {
                this.rainDrops = [];
                this.skyDarkness = Math.max(0, this.skyDarkness - 0.02);
            }
            
            if (this.current === 'fog') {
                this.updateFog();
                this.skyDarkness = Math.min(0.5, this.skyDarkness + 0.02);
            } else {
                this.targetFogOpacity = 0;
            }
            
            this.fogOpacity += (this.targetFogOpacity - this.fogOpacity) * 0.02;
        }
        
        changeWeather() {
            const rand = Math.random();
            if (rand < 0.4) {
                this.setWeather('clear');
            } else if (rand < 0.6) {
                this.setWeather('rain');
            } else if (rand < 0.8) {
                this.setWeather('storm');
            } else {
                this.setWeather('fog');
                this.fogHeight = Math.random() > 0.5 ? 'bottom' : 'platform';
            }
        }
        
        setWeather(type) {
            this.current = type;
            
            if (type === 'rain' || type === 'storm') {
                if (audioManager) {
                    audioManager.startRainSound();
                    audioManager.setRainVolume(type === 'storm' ? 0.15 : 0.1);
                }
            } else {
                if (audioManager) {
                    audioManager.setRainVolume(0);
                }
            }
        }
        
        updateRain() {
            while (this.rainDrops.length < this.maxRainDrops) {
                this.rainDrops.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * -100,
                    speed: Math.random() * 8 + 12,
                    length: Math.random() * 15 + 10
                });
            }
            
            for (let i = this.rainDrops.length - 1; i >= 0; i--) {
                const drop = this.rainDrops[i];
                drop.y += drop.speed;
                drop.x -= 1;
                
                if (drop.y > CANVAS_HEIGHT + 20) {
                    this.rainDrops.splice(i, 1);
                }
            }
        }
        
        updateLightning() {
            this.lightningTimer++;
            
            if (this.lightningTimer >= this.nextLightning) {
                this.lightningFlash = 1;
                this.lightningTimer = 0;
                this.nextLightning = Math.random() * 400 + 200;
                
                if (audioManager) {
                    setTimeout(() => {
                        if (audioManager) audioManager.playSfx('thunder');
                    }, Math.random() * 500 + 100);
                }
            }
            
            this.lightningFlash *= 0.9;
        }
        
        updateFog() {
            this.targetFogOpacity = 0.6;
            
            if (this.fogLayers.length < 15) {
                this.fogLayers.push({
                    x: Math.random() * CANVAS_WIDTH * 1.5 - CANVAS_WIDTH * 0.25,
                    y: this.fogHeight === 'bottom' ? CANVAS_HEIGHT - Math.random() * 200 : GROUND_Y - 180 - Math.random() * 100,
                    width: Math.random() * 300 + 200,
                    speed: Math.random() * 0.3 + 0.1
                });
            }
            
            for (const layer of this.fogLayers) {
                layer.x += layer.speed;
                if (layer.x > CANVAS_WIDTH + layer.width) {
                    layer.x = -layer.width;
                }
            }
        }
        
        draw(ctx, camX) {
            if (this.current === 'rain' || this.current === 'storm') {
                ctx.strokeStyle = 'rgba(150, 180, 255, 0.4)';
                ctx.lineWidth = 1;
                for (const drop of this.rainDrops) {
                    ctx.beginPath();
                    ctx.moveTo(drop.x, drop.y);
                    ctx.lineTo(drop.x - 3, drop.y + drop.length);
                    ctx.stroke();
                }
            }
            
            if (this.lightningFlash > 0.1) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.lightningFlash * 0.5})`;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }
            
            if (this.fogOpacity > 0.01) {
                for (const layer of this.fogLayers) {
                    const gradient = ctx.createRadialGradient(
                        layer.x + layer.width / 2, layer.y,
                        0,
                        layer.x + layer.width / 2, layer.y,
                        layer.width / 2
                    );
                    gradient.addColorStop(0, `rgba(180, 180, 190, ${this.fogOpacity * 0.8})`);
                    gradient.addColorStop(1, 'rgba(180, 180, 190, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(layer.x + layer.width / 2, layer.y, layer.width / 2, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = `rgba(150, 150, 160, ${this.fogOpacity * 0.3})`;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }
        }
        
        getCloudColor() {
            if (this.current === 'storm') return 'rgba(60, 60, 80, 0.9)';
            if (this.current === 'rain') return 'rgba(100, 100, 120, 0.8)';
            return null;
        }
        
        getSkyDarkness() {
            return this.skyDarkness;
        }
    }

    // ========================================
    // PROCEDURAL GENERATOR
    // ========================================
    class ProceduralGenerator {
        static getDiffVal(s, d) { return lerp(DIFFICULTY_SETTINGS[s][0], DIFFICULTY_SETTINGS[s][1], d); }
        
        // Helper to get random enemy type based on spawn weights
        static getRandomEnemyType() {
            const totalWeight = ENEMY_TYPES.reduce((sum, t) => sum + t.spawnWeight, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < ENEMY_TYPES.length; i++) {
                random -= ENEMY_TYPES[i].spawnWeight;
                if (random <= 0) return i;
            }
            return 0; // Fallback to first type
        }
        
        static generateChunk(startX) {
            const cs = Math.floor(startX / CHUNK_WIDTH);
            const rand = () => seededRandom(cs + seed);
            const obj = { platforms: [], coins: [], enemies: [] };
            
            const gapSize = this.getDiffVal('gapSize', difficulty);
            const hasGap = rand() > 0.3 && startX > 500;
            
            if (!hasGap) {
                obj.platforms.push(new Platform(startX, GROUND_Y, CHUNK_WIDTH, 40, 'ground'));
            } else {
                const gapStart = startX + randomRange(50, CHUNK_WIDTH - gapSize - 50);
                obj.platforms.push(new Platform(startX, GROUND_Y, gapStart - startX, 40, 'ground'));
                obj.platforms.push(new Platform(gapStart + gapSize, GROUND_Y, CHUNK_WIDTH - (gapStart - startX) - gapSize, 40, 'ground'));
            }
            
            const platH = this.getDiffVal('platformHeight', difficulty);
            const moveChance = this.getDiffVal('movingPlatformChance', difficulty);
            
            if (Math.random() < 0.4) {
                const px = startX + randomRange(30, CHUNK_WIDTH - 130);
                const py = GROUND_Y - randomRange(platH, platH + 10);
                const pw = randomRange(100, 140);
                
                const isMoving = Math.random() < moveChance;
                const plat = new Platform(px, py, pw, 25, 'floating');
                if (isMoving) {
                    const moveRange = randomRange(40, 70);
                    const moveAxis = Math.random() > 0.5 ? 'x' : 'y';
                    plat.setMoving(moveRange, 0.015, moveAxis);
                }
                obj.platforms.push(plat);
                
                const numCoins = Math.floor(randomRange(1, 4));
                for (let i = 0; i < numCoins; i++) {
                    const coinX = px + 15 + (i * 35);
                    const coinY = py - 30;
                    const isGold = Math.random() < 0.1;
                    obj.coins.push(new Coin(coinX, coinY, isGold));
                }
            }
            
            const coinFreq = this.getDiffVal('coinFrequency', difficulty);
            if (rand() > coinFreq) {
                const nc = Math.floor(randomRange(1, 4));
                for (let i = 0; i < nc; i++) obj.coins.push(new Coin(startX + randomRange(30, CHUNK_WIDTH - 30), GROUND_Y - randomRange(50, 100), false));
            }
            
            const enemyFreq = this.getDiffVal('enemyFrequency', difficulty);
            if (rand() < enemyFreq && startX > 300) {
                const es = this.getDiffVal('enemySpeed', difficulty);
                const enemyType = this.getRandomEnemyType();  // Random enemy type!
                obj.enemies.push(new Enemy(startX + randomRange(50, CHUNK_WIDTH - 100), GROUND_Y - 50, randomRange(60, 120), es, enemyType));
            }
            
            return obj;
        }
    }

    // ========================================
    // SCOREBOARD
    // ========================================
    async function loadScores() {
        if (!supabaseClient) return [];
        try {
            const { data, error } = await supabaseClient.from('scores').select('*').order('score', { ascending: false }).limit(10);
            if (error) return [];
            return data || [];
        } catch (e) { return []; }
    }
    
    async function submitScore(name, sv, dv, cv) {
        if (!supabaseClient) return false;
        try {
            const { error } = await supabaseClient.from('scores').insert([{ 
                player_name: name || 'Anonymous', 
                score: sv
            }]);
            if (error) console.error('Supabase insert error:', error);
            return !error;
        } catch (e) { console.error('Submit score exception:', e); return false; }
    }
    
    async function displayScoreboard() {
        const tbody = document.getElementById('scoreboard-body');
        const loading = document.getElementById('scoreboard-loading');
        tbody.innerHTML = '';
        loading.style.display = 'block';
        
        try {
            const scores = await loadScores();
            if (scores.length === 0) tbody.innerHTML = '<tr><td colspan="3" style="text-align:center;color:#aaa;">No scores yet!</td></tr>';
            else {
                for (let i = 0; i < Math.min(10, scores.length); i++) {
                    const e = scores[i];
                    const rc = i < 3 ? 'rank-' + (i + 1) : '';
                    const row = document.createElement('tr');
                    row.innerHTML = '<td class="' + rc + '">' + (i + 1) + '</td><td class="' + rc + '">' + escapeHtml(e.player_name) + '</td><td class="' + rc + '">' + e.score.toLocaleString() + '</td>';
                    tbody.appendChild(row);
                }
            }
            loading.style.display = 'none';
        } catch (e) { loading.textContent = 'Error loading scores'; console.error('Display error:', e); }
        document.getElementById('scoreboard-section').style.display = 'block';
    }
    
    function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }
    function showPenaltyPopup() { const p = document.getElementById('penalty-popup'); p.classList.add('show'); setTimeout(() => p.classList.remove('show'), 1500); }
    function showZoneIndicator() {
        const zn = ['Forest', 'Desert', 'Cave', 'Darkness', 'Void'];
        const ind = document.getElementById('zone-indicator');
        ind.textContent = 'üåç Zone ' + (currentZone + 1) + ': ' + (zn[currentZone] || 'Unknown');
        ind.classList.add('show');
        setTimeout(() => ind.classList.remove('show'), 2000);
    }

    // ========================================
    // INITIALIZE
    // ========================================
    assetManager = new AssetManager();
    audioManager = new AudioManager();
    background = new Background();
    weather = new Weather();

    // ========================================
    // EVENT LISTENERS - KEYBOARD
    // ========================================
    document.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === ' ') {
            keys.jump = true;
            e.preventDefault();
        }
    });
    
    document.addEventListener('keyup', function(e) {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === ' ') keys.jump = false;
    });
    
    // ========================================
    // EVENT LISTENERS - MOBILE TOUCH
    // ========================================
    function setupMobileButton(id, keyName, isJump) {
        const btn = document.getElementById(id);
        if (!btn) return;
        
        btn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (isJump) keys.jump = true;
            else keys[keyName] = true;
        }, { passive: false });
        
        btn.addEventListener('touchend', function(e) {
            e.preventDefault();
            if (isJump) keys.jump = false;
            else keys[keyName] = false;
        }, { passive: false });
        
        btn.addEventListener('mousedown', function(e) {
            e.preventDefault();
            if (isJump) keys.jump = true;
            else keys[keyName] = true;
        });
        
        btn.addEventListener('mouseup', function(e) {
            e.preventDefault();
            if (isJump) keys.jump = false;
            else keys[keyName] = false;
        });
        
        btn.addEventListener('mouseleave', function(e) {
            if (isJump) keys.jump = false;
            else keys[keyName] = false;
        });
    }
    
    setupMobileButton('btn-left', 'left', false);
    setupMobileButton('btn-right', 'right', false);
    setupMobileButton('btn-jump', null, true);
    
    // ========================================
    // OTHER EVENT LISTENERS
    // ========================================
    document.getElementById('start-btn').addEventListener('click', startGame);
    
    document.getElementById('restart-btn').addEventListener('click', function() {
        document.getElementById('game-over-screen').style.display = 'none';
        hideGamepadNameEntry();
        document.getElementById('scoreboard-section').style.display = 'none';
        document.getElementById('player-name-input').value = '';
        document.getElementById('submit-status').textContent = '';
        startGame();
    });
    
    document.getElementById('submit-score-btn').addEventListener('click', async function(e) {
        e.preventDefault();
        const name = document.getElementById('player-name-input').value.trim() || 'Anonymous';
        const btn = document.getElementById('submit-score-btn');
        const status = document.getElementById('submit-status');
        
        btn.disabled = true;
        status.textContent = 'Submitting...';
        
        const success = await submitScore(name, score, distance, coins_collected);
        status.textContent = success ? 'Submitted!' : 'Failed';
        status.style.color = success ? '#00FF00' : '#FF6600';
        
        document.getElementById('name-input-section').style.display = 'none';
        await displayScoreboard();
        btn.disabled = false;
    });
    
    document.getElementById('player-name-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') document.getElementById('submit-score-btn').click();
    });

    // ========================================
    // GAME FUNCTIONS
    // ========================================
    function startGame() {
        audioManager.init();
        
        if (musicPlayer) musicPlayer.start();
        
        score = 0; coins_collected = 0; distance = 0; lives = 3;
        cameraX = 0; maxCameraX = 0; difficulty = 0; currentZone = 0;
        lastGeneratedX = 0; seed = Math.floor(Math.random() * 10000);
        
        platforms = []; coinsArray = []; enemies = []; particles = [];
        player = new Player(100, CANVAS_HEIGHT - 110);
        
        for (let x = 0; x < CANVAS_WIDTH + GENERATION_DISTANCE; x += CHUNK_WIDTH) generateChunk(x);
        
        gameState = 'playing';
        document.getElementById('start-screen').style.display = 'none';
        gameLoop();
    }
    
    function generateChunk(x) {
        if (x < lastGeneratedX) return;
        lastGeneratedX = x + CHUNK_WIDTH;
        const obj = ProceduralGenerator.generateChunk(x);
        platforms.push(...obj.platforms);
        coinsArray.push(...obj.coins);
        enemies.push(...obj.enemies);
    }
    
    function cleanupObjects() {
        const cx = cameraX - CLEANUP_DISTANCE;
        platforms = platforms.filter(p => p.x + p.width > cx);
        coinsArray = coinsArray.filter(c => c.x + c.width > cx);
        enemies = enemies.filter(e => e.x + e.width > cx);
    }

    function gameLoop() {
        if (gameState !== 'playing') return;
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        update();
        render();
        updateHUD();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        pollGamepad();  // Poll gamepad input every frame
        for (const p of platforms) p.update();
        for (const c of coinsArray) c.update();
        for (const e of enemies) e.update();
        player.update();
        
        const targetX = player.x - CANVAS_WIDTH / 3;
        cameraX += (targetX - cameraX) * 0.1;
        
        cameraX = Math.max(cameraX, maxCameraX);
        maxCameraX = Math.max(maxCameraX, cameraX);
        
        distance = Math.max(distance, player.x / 10);
        difficulty = Math.min(1, distance / 5000);
        
        const newZone = Math.floor(distance / 500);
        if (newZone !== currentZone) { currentZone = newZone; showZoneIndicator(); }
        
        while (lastGeneratedX < player.x + GENERATION_DISTANCE) generateChunk(lastGeneratedX);
        
        cleanupObjects();
        
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].isDead()) particles.splice(i, 1);
        }
        
        if (weather) weather.update();
        
        if (player.y > CANVAS_HEIGHT + 100) {
            player.x = cameraX + 100;
            player.y = 0;
            player.vx = 0;
            player.vy = 0;
            player.takeDamage();
        }
        
        if (player.x < cameraX + 20) {
            player.x = cameraX + 20;
            player.vx = 0;
        }
    }

    function render() {
        background.draw(ctx, cameraX, weather);
        
        for (const p of platforms) if (p.x + p.width > cameraX && p.x < cameraX + CANVAS_WIDTH) p.draw(ctx, cameraX);
        for (const c of coinsArray) if (c.x + c.width > cameraX && c.x < cameraX + CANVAS_WIDTH) c.draw(ctx, cameraX);
        for (const e of enemies) if (e.x + e.width > cameraX && e.x < cameraX + CANVAS_WIDTH) e.draw(ctx, cameraX);
        
        player.draw(ctx, cameraX);
        for (const p of particles) p.draw(ctx, cameraX);
        
        drawVFX();
        
        if (weather) weather.draw(ctx, cameraX);
        
        if (weather && weather.getSkyDarkness() > 0) {
            ctx.fillStyle = `rgba(30, 30, 50, ${weather.getSkyDarkness() * 0.4})`;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }
    }

    function drawVFX() {
        // Vignette effect
        const vig = ctx.createRadialGradient(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, CANVAS_HEIGHT * 0.4, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, CANVAS_HEIGHT * 0.8);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(1, 'rgba(0,0,0,0.3)');
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }

    function updateHUD() {
        document.getElementById('coin-count').textContent = coins_collected;
        document.getElementById('score-count').textContent = score.toLocaleString();
        document.getElementById('distance-count').textContent = Math.floor(distance);
        document.getElementById('lives-count').textContent = lives;
        
        document.getElementById('difficulty-fill').style.width = (difficulty * 100) + '%';
        const dt = difficulty < 0.25 ? 'Easy' : difficulty < 0.5 ? 'Medium' : difficulty < 0.75 ? 'Hard' : difficulty < 1 ? 'Extreme' : 'MAX';
        document.getElementById('difficulty-text').textContent = 'Difficulty: ' + dt;
    }

    // ========================================
    // RESPONSIVE
    // ========================================
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const maxW = window.innerWidth * 0.95;
        const maxH = window.innerHeight * 0.95;
        const scale = Math.min(maxW / CANVAS_WIDTH, maxH / CANVAS_HEIGHT, 1.3);
        container.style.transform = 'scale(' + scale + ')';
        container.style.transformOrigin = 'center center';
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', function() {
        setTimeout(resizeCanvas, 100);
    });
    
    resizeCanvas();

    console.log('WiFi Router Adventure - ENDLESS MODE loaded!');
    </script>
</body>
</html>
